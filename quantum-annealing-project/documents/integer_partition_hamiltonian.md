# 整数分割問題のハミルトニアン定義

## 問題設定
与えられた整数のリスト `numbers = [n₁, n₂, ..., nₖ]` を2つの集合A, Bに分割し、それぞれの集合の和の差を最小化する問題。

## ハミルトニアンの定義

### 変数定義
- `sᵢ ∈ {-1, +1}`: 数値 `nᵢ` がどちらの集合に属するかを表すスピン変数
- `sᵢ = +1` なら集合A、`sᵢ = -1` なら集合B

### スピン変数による巧妙な表現

スピン変数を使うことで、集合の和の差を直接表現できます：

```
S_A - S_B = ∑ᵢ nᵢ·sᵢ
```

**なぜこの式が成り立つか：**
- `sᵢ = +1` のとき: 数値 `nᵢ` は集合Aに属し、`S_A` に `+nᵢ` で寄与
- `sᵢ = -1` のとき: 数値 `nᵢ` は集合Bに属し、`S_B` に `+nᵢ` で寄与するが、式では `-nᵢ` となる

### 目的関数
2つの集合の和の差の二乗を最小化:

```
H = (S_A - S_B)² = (∑ᵢ nᵢ·sᵢ)²
```

### 実装上のハミルトニアン

```python
sum_A = sum(numbers[i] * x[i] for i in range(n))  # これは実際は S_A - S_B
objective = sum_A ** 2  # (S_A - S_B)²
```

pyquboが内部で以下のように展開：
```
H = ∑ᵢ∑ⱼ nᵢ·nⱼ·sᵢ·sⱼ
```

### スピン変数の利点

**制約が不要：**
- バイナリ変数では `S_A + S_B = S_total` の制約が必要
- スピン変数では自動的に各要素がどちらかの集合に属する
- 制約なしで直接 `(S_A - S_B)²` を最小化可能

**簡潔な表現：**
- 複雑な制約付き最適化問題が、単純な二次形式に変換される
- ペナルティ項が不要

### 実装上の工夫

1. **計算量の大幅削減**: 
   - 元の実装: `O(n²)` の二重ループ
   - 簡素化後: `O(n)` の単一ループ

2. **コードの簡潔性**:
   - 複雑な展開式から1行の表現へ
   - 可読性と保守性の向上

3. **QUBO変換**:
   - pyquboが `(Σ nᵢ·xᵢ)²` を自動的にQUBO形式に展開
   - 内部で二次項 `∑ᵢ∑ⱼ nᵢ·nⱼ·xᵢ·xⱼ` に変換

## コード実装との対応

```python
# スピン変数の定義
x = [Spin(f'x{i}') for i in range(n)]

# S_A - S_B の計算（変数名は sum_A だが実際は差）
sum_A = sum(numbers[i] * x[i] for i in range(n))  # ∑ᵢ nᵢ·sᵢ

# (S_A - S_B)² の最小化
objective = sum_A ** 2
```

**注意：** 変数名 `sum_A` は誤解を招きやすいですが、実際は集合の和の **差** を表現しています。

## 物理的解釈
- エネルギー最小状態が最適解に対応
- 各スピンが集合の所属を表現
- イジング模型として量子アニーリングで解ける